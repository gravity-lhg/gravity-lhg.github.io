<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>刘浩光的个人博客</title>
    <description>为天地立心, 为生民立命, 为往圣继绝学, 为万世开太平</description>
    <link>http://localhost:4000//</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 13 Mar 2023 21:34:35 +0800</pubDate>
    <lastBuildDate>Mon, 13 Mar 2023 21:34:35 +0800</lastBuildDate>
    <generator>Jekyll v4.3.2</generator>
    
      <item>
        <title>Compiling Stuffs</title>
        <description>&lt;h2 id=&quot;gccg-编译make-编译cmake-编译&quot;&gt;GCC/G++ 编译、make 编译、CMake 编译&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;计算机只能识别二进制代码，并不能够直接识别诸如 C++ 等高级语言编写的代码（源代码），所以将编写的高级语言代码转换为二进制代码，这样计算机才可以识别运行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;根据源代码转换为二进制代码的时机不同，可以将语言分为 编译型 语言和 解释型 语言。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;编译型语言：使用编译器一次性将代码编译为可执行文件，一次编译可重复执行，代表有 C、C++、Golang 等。其有着执行效率高，编译后程序不可修改，保密性好等特点，但其可移植性差。&lt;/li&gt;
  &lt;li&gt;解释型语言：使用解释器一边解释一边执行，甬道哪些源代码就解释哪些源代码，不会生成可执行文件，代表有 Python、JavaScript、PHP 等。其移植性较好，只要有解释环境即可，但运行速度慢，效率低。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;注：&lt;/em&gt;&lt;/strong&gt; Java 是一种混合型语言，其先将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.java&lt;/code&gt; 文件编译为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.class&lt;/code&gt; 类型文件，再解释运行。&lt;/p&gt;

&lt;h3 id=&quot;1-gccg-简单编译&quot;&gt;1. GCC/G++ 简单编译&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;下述整个过程围绕 C++ 语言展开&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;从 C++ 高级语言到计算机可执行的二进制语言的过程叫做编译（compiling），单文件一步到位的编译指令为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;g++ main.cpp -o main&lt;/code&gt;，其中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main.cpp&lt;/code&gt; 为要编译的文件，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-o&lt;/code&gt; 为 output，后面的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; 为编译后的可执行文件名，通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;./main&lt;/code&gt; 运行。此过程一共要经历以下四个步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;预处理：将文件里的头文件、宏定义等做展开或替换。使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;g++ -E main.cpp -o test.i&lt;/code&gt; 命令，参数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-E&lt;/code&gt; 表示仅处理到预处理阶段&lt;/li&gt;
  &lt;li&gt;编译：将预处理后的文件编译（翻译）成汇编语言。使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;g++ -S main.cpp -o test.s&lt;/code&gt; 命令，参数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-S&lt;/code&gt; 表示仅处理到编译阶段&lt;/li&gt;
  &lt;li&gt;汇编：将编译后程序翻译成计算机可以直接理解的二进制机械码。使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;g++ -c main.cpp -o test.o&lt;/code&gt; 命令，参数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-c&lt;/code&gt; 仅表示处理到汇编阶段&lt;/li&gt;
  &lt;li&gt;连接：基于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.o&lt;/code&gt; 的目标文件，链接库，生成可执行文件。使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;g++ test.o -o test&lt;/code&gt; 命令，生成可执行文件&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面将项目目录复杂化，其目录结构如下：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cppDir % tree &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
├── include
│   └── calc.h
├── main
├── main.cpp
└── src
    └── calc.cpp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;二级目录 include 下有一个头文件，src 目录下放了实现它的源文件，根目录下的源文件 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main.cpp&lt;/code&gt; 用来调用它&lt;/li&gt;
  &lt;li&gt;应该采用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;g++ main.cpp src/calc.cpp -Iinclude -o main&lt;/code&gt; 命令来进行编译。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-I&lt;/code&gt; 后跟自定义的头文件目录位置&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;静态库与动态库&quot;&gt;静态库与动态库&lt;/h4&gt;

&lt;p&gt;某些经常复用的代码块，可以编写为库文件，方便部署、发布，还可以对模块代码进行保密（对外仅提供接口即可）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;什么是库？&lt;/p&gt;

    &lt;p&gt;库是写好的、现有的、成熟的、可以复用的代码。本质上来说，库是一种可执行代码的二进制式，可以被操作系统载入内存执行。库有两种：静态库 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;（.a .lib）&lt;/code&gt; 和动态库 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;（.so .dll）&lt;/code&gt;。所谓静态、动态是指链接。库文件是事先编译好的方法的合集&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;静态库和动态库的区别&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;静态库的扩展名一般为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.a&lt;/code&gt; 或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.lib&lt;/code&gt;；动态库的扩展名一般为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.so&lt;/code&gt; 或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.dll&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;静态库在编译时会直接整合到目标程序中，编译成功的可执行文件可独立运行；动态库在编译时不会放到连接的目标程序中，即可执行文件无法单独运行&lt;/li&gt;
      &lt;li&gt;静态库和动态库最本质的区别就是：&lt;strong&gt;该库是否被编译进目标（程序）内部。&lt;/strong&gt;&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;&lt;strong&gt;静态（函数）库：&lt;/strong&gt;一般扩展名为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;（.a 或 .lib）&lt;/code&gt;，这类的函数库通常扩展名为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;libxxx.a&lt;/code&gt; 或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xxx.lib&lt;/code&gt;。这类库在编译的时候会直接整合到目标程序中，所以利用静态函数库编译成的文件会比较大，这类函数库最大的优点就是编译成功的可执行文件可以独立运行，而不再需要向外部要求读取函数库的内容；但是从升级难易度来看明显没有优势，如果函数库更新，需要重新编译&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;动态（函数）库：&lt;/strong&gt;一般扩展名为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;（.so 或 .dll）&lt;/code&gt;，这类函数库通常名为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;libxxx.so&lt;/code&gt; 或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xxx.dll&lt;/code&gt;。与静态函数库被整个捕捉到程序中不同，动态函数库在编译的时候，在程序里只有一个“指向”的位置而已，也就是说当可执行文件需要使用到函数库的机制时，程序才会去读取函数库来使用；也就是说可执行文件无法单独运行。这样从产品功能升级角度方便升级，只要替换对应动态库即可，不必重新编译整个可执行文件&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;两者的优缺点&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;静态库
    &lt;ul&gt;
      &lt;li&gt;优点：静态库被打包到应用程序中加载速度快；发布程序无需提供静态库，移植方便&lt;/li&gt;
      &lt;li&gt;缺点：相同的库文件数据可能在内存中被加载多份，消耗系统资源，浪费内存；库文件更新需要重新编译项目文件，生成新的可执行程序，浪费时间&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;动态库
    &lt;ul&gt;
      &lt;li&gt;优点：可实现不同进程间的资源共享；动态库升级简单，只需要替换库文件，无需重新编译应用程序；可以控制何时加载动态库，不调用库函数动态库不会被加载&lt;/li&gt;
      &lt;li&gt;缺点：加载速度比静态库慢；发布程序需要提供依赖的动态库&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;静态库和动态库的制作&quot;&gt;静态库和动态库的制作&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;静态库的生成&lt;/strong&gt;（以上面实例为例）&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;静态库本身为一个二进制目标文件，采用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;g++ -c src/calc.cpp -Iinclude -o calc.o&lt;/code&gt; 命令生成 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.o&lt;/code&gt; 目标文件。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;将目标文件归档为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.a&lt;/code&gt; 的静态库。在命名的时候，采用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lib + 库名 + 后缀&lt;/code&gt; 格式，例如上述文件命名为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;libCalc.a&lt;/code&gt;，代表名叫 Calc 的静态链接库。所采用的命令为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ar rs libCalc.a calc.o&lt;/code&gt;。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;静态库做好后，编译 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main.cpp&lt;/code&gt; 并链接上此静态库，注意链接时也需要头文件的支持。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-l&lt;/code&gt;表示链接哪个库，直接 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-l库名&lt;/code&gt; 即可，还需要告诉编译器从哪里找这个库，使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-L&lt;/code&gt; 进行指定。此处采用的命令为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;g++ main.cpp -Iinclude -L. -lCalc -o main&lt;/code&gt;。&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;&lt;em&gt;注：&lt;/em&gt;&lt;/strong&gt; 参数和参数实体中间空格可有可无，一般不写空格&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;动态库的生成&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;动态库以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.so&lt;/code&gt; 结尾，需要加上 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-shared&lt;/code&gt; 参数指定生成的是动态库，直接用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;g++ src/calc.cpp -Iinclude -shared -fPIC -o libcalc.so&lt;/code&gt; 命令生成（此处也可以分开来做，先使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-fPIC&lt;/code&gt; 生存 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.o&lt;/code&gt; 文件，再使用  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-shared&lt;/code&gt; 生存 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.so&lt;/code&gt; 文件）。此处的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-fPIC&lt;/code&gt; 作用于编译阶段，告诉编译器产生与位置无关代码（Position-Independent Code），因此产生的代码中，没有绝对地址，全部使用相对地址，故代码可以被加载器加载到内存的任意位置，都可以正确的执行。这正是共享库所要求的，共享库被加载时，在内存的位置不是固定的。&lt;/li&gt;
      &lt;li&gt;接下来编译 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main.cpp&lt;/code&gt;，并告诉连接器你想要链接哪个库。采用命令为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;g++ main.cpp -Iinclude -L. -lCalc -o main&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-g&lt;/code&gt; 参数使得在编译的时候生成调试信息，生成为可执行文件体积会稍微大一些&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-make-编译&quot;&gt;2. make 编译&lt;/h3&gt;

&lt;p&gt;当我们的工程扩展到很多个文件、很多个目录（方便管理、维护）的时候，直接通过 g++ 进行工程的编译就显得捉襟见肘了，此时就需要通过写 makefile 脚本，使用 make 命令来进行项目的构建。&lt;/p&gt;

&lt;p&gt;makefile 是包含了整个工程编译规则的文件。其定义了一些列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至更复杂的功能。因此 makefile 就像一个 shell 脚本一样，其中也可以执行操作系统的命令。&lt;/p&gt;

&lt;p&gt;makefile 的好处是&lt;strong&gt;自动化编译&lt;/strong&gt;，一旦写好，只需要一个 make 命令，整个工程就可以自动编译，极大提高了开发的效率。再此之前，先粗略看看 makefile 的规则：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;target ... : prerequisites ...
	&lt;span class=&quot;nb&quot;&gt;command&lt;/span&gt;
	...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;target&lt;/code&gt; 可以是一个目标文件（object file），也可以是一个执行文件，还可以是一个标签（label）&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prerequisites&lt;/code&gt; 为生成该 target 所依赖的文件或 target&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;command&lt;/code&gt; 是生成该 target 所需要执行的文件（或 任意的 shell 命令）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;makefile 中最核心的内容为依赖关系。所以如果 target 不存在或 prerequisites 中有比 target 更新的文件，command 命令才会被执行。（更具时间戳进行判断）&lt;/p&gt;

&lt;p&gt;下面就一个实际例子来进行简单的 make 编译说明：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cppDir % tree &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
├── include
│   ├── test1.h
│   └── test2.h
├── main.cpp
├── makefile
└── src
    ├── test1.cpp
    └── test2.cpp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;现在有以上的一目录结构，为其写一个最初级的 makefile 如下：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# /bin/sh/&lt;/span&gt;

main: main.o test1.o test2.o
    g++ main.o test1.o test2.o &lt;span class=&quot;nt&quot;&gt;-Iinclude-o&lt;/span&gt; main

main.o: main.cpp
    g++ &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; main.cpp &lt;span class=&quot;nt&quot;&gt;-g&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-Wall&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-Iinclude&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; main.o
test1.o: src/test1.cpp
    g++ &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; test1.cpp &lt;span class=&quot;nt&quot;&gt;-g&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-Wall&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-Iinclude&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; test1.o
test2.o: src/test2.cpp
    g++ &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; test2.cpp &lt;span class=&quot;nt&quot;&gt;-g&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-Wall&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-Iinclude&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; test2.o

clean:
    &lt;span class=&quot;nb&quot;&gt;rm&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.o main &lt;span class=&quot;nt&quot;&gt;-rf&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看到本项目 &lt;strong&gt;最终要生成的目标文件（第一个出现的 target）&lt;/strong&gt;为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt;，而 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; 目标文件依赖于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main.o test1.o test2.o&lt;/code&gt; 三个二进制文件，三个二进制文件分别依赖于与它们同名的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.cpp&lt;/code&gt; 文件。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;clean&lt;/code&gt; 后面没有依赖项，因此它是一个 label，可以使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make clean&lt;/code&gt; 来执行此 label 下的 command 命令。它的作用是清理产生的中间文件。&lt;/p&gt;

&lt;p&gt;但上面的写法有点繁琐（文件名写好几次了），在文件很多的时候写起来很麻烦，也很容易出错。所以可以通过变量的方式进行简化，简化后版本如下：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# /bin/sh/&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;OBJS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;main.o test1.o test2.o
&lt;span class=&quot;nv&quot;&gt;CC&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;g++
CFLAGS+&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-g&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-Wall&lt;/span&gt;

main:&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;OBJS&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;CC&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$^&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-Iinclude&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; main

main.o: main.cpp
    &lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;CC&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$^&lt;/span&gt; &lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;CFLAGS&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-Iinclude&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; main.o
test1.o: src/test1.cpp
    &lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;CC&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$^&lt;/span&gt; &lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;CFLAGS&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-Iinclude&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; test1.o
test2.o: src/test2.cpp
    &lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;CC&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$^&lt;/span&gt; &lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;CFLAGS&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-Iinclude&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; test2.o

clean:
    &lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;RM&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.o main &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt;                     
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OBJS&lt;/code&gt; 变量来代替三个依赖项，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CC&lt;/code&gt; 代替 g++， &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CFLAGS&lt;/code&gt; 代替编译所需的参数。makefile 中变量采用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$()&lt;/code&gt; 来表示，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$^&lt;/code&gt; 表示为此处的依赖项， &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$(RM)&lt;/code&gt; 为默认的变量，表示 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rm -f&lt;/code&gt;。这样就可以减少文件名的书写。但当文件比较多时，写起来还是很麻烦，所以又有了以下的终极版本：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# /bin/sh/&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;OBJS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;main.o test1.o test2.o
&lt;span class=&quot;nv&quot;&gt;CC&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;g++
CFLAGS+&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-g&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-Wall&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;INCL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-Iinclude&lt;/span&gt;

main:&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;OBJS&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;CC&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$^&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$@&lt;/span&gt;

%.o: %.cpp
    &lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;CC&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$^&lt;/span&gt; &lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;CFLAGS&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;INCL&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$@&lt;/span&gt;
%.o: src/%.cpp
    &lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;CC&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$^&lt;/span&gt; &lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;CFLAGS&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;INCL&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$@&lt;/span&gt;

clean:
    &lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;RM&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.o main &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;采用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$@&lt;/code&gt; 来表示 target ；采用类似于递推的方式，使用 % 在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OBJS&lt;/code&gt; 中进行通配来实现多文件的编译，代码复用性变得更强了。&lt;/p&gt;

&lt;p&gt;以上只是一个简单的 makefile 使用示例，更详尽的 makefile 编写技巧见程浩老师的《跟我一起写Makefile》，其2022重置版 pdf 下载地址：https://seisman.github.io/how-to-write-makefile/Makefile.pdf&lt;/p&gt;

&lt;h3 id=&quot;3-cmake-编译&quot;&gt;3. CMake 编译&lt;/h3&gt;

&lt;p&gt;未完待续。。。&lt;/p&gt;
</description>
        <pubDate>Mon, 13 Mar 2023 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2023/03/13/First_compiling.html</link>
        <guid isPermaLink="true">http://localhost:4000/2023/03/13/First_compiling.html</guid>
        
        <category>Programming</category>
        
        
      </item>
    
      <item>
        <title>Region Proposal by Guided Anchoring</title>
        <description>&lt;h2 id=&quot;一种利用语义特征引导的锚框自适应方法ga&quot;&gt;一种利用语义特征引导的锚框自适应方法（GA）&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;文章发表于 CVPR 2019.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;论文链接地址：&lt;a href=&quot;https://openaccess.thecvf.com/content_CVPR_2019/papers/Wang_Region_Proposal_by_Guided_Anchoring_CVPR_2019_paper.pdf&quot;&gt;Region Proposal by Guided Anchoring&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;1-introduction&quot;&gt;1. Introduction&lt;/h3&gt;

&lt;p&gt;合理的锚框设计有两个一般规则：对齐和一致性。对齐是指：使用卷积特征作为锚框表示时，锚框中心需要与特征图像素很好地对齐。一致性是指：在特征图不同位置上，感受野和语义范围应该与对应锚框的规模和形状一致。&lt;/p&gt;

&lt;p&gt;对于大多数 anchor_based 的检测方法，anchors 由统一方案定义，其中特征图中的每个位置都与 k 个具有预定义比例和纵横比的 anchors 相关联。均匀锚框预设方案并不一定是锚框的最佳制备方案（&lt;strong&gt;次优&lt;/strong&gt;），这种方案可能导致两个问题；&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;必须为不同的问题预先定义一组固大小、定长宽比的整齐锚框，这种设计可能会妨碍检测器的速度和准确性。&lt;/li&gt;
  &lt;li&gt;为了保持足够高的提议查全率（recall），需要预设大量的锚框，这样会造成锚框大多对应于与兴趣对象无关的假候选点。同时，大量的锚框会导致大量的计算成本，特别是当管道在提案阶段涉及一个重分类器时。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于观察到物体不是均匀分布在图像上。物体的尺度也与图像内容、位置和场景的几何形状密切相关。根据这种观察，&lt;strong&gt;将采用两步生成稀疏锚框：&lt;/strong&gt;首先识别可能包含对象的子区域，然后确定不同位置的形状。（引导锚定模块）&lt;/p&gt;

&lt;p&gt;可学习锚指锚框的比例和纵横比是可变的，它会打破锚框设计的一致性规则。为了使得可学习锚框得以精确的分类和回归，不同的特征图像素必须学习适应相应锚框的自适应表示。（锚框几何调整模块）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;本文贡献主要有以下四点：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;提出了一种新的锚定方案，该方案能够预测非均匀和任意形状的锚，而不是密集和预定义的锚&lt;/li&gt;
  &lt;li&gt;用两个因式条件分布构造联合锚分布，并设计两个模块分别对其进行建模&lt;/li&gt;
  &lt;li&gt;研究了将特征与相应锚框对齐的重要性，并设计了基于锚框形状的特征自适应模块来细化特征&lt;/li&gt;
  &lt;li&gt;研究了 two-stage 检测器的高质量提议的使用，并提出了一种提高训练模型性能的方案&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2-methodology&quot;&gt;2. Methodology&lt;/h3&gt;

&lt;p&gt;整个工作的目标是开发一个更有效的锚定方案，以安排具有可学习形状的锚框，考虑到物体的位置和形状的非均匀分布。&lt;/p&gt;

&lt;p&gt;物体的位置和形状可以用 $(x, y, w, h)$ 形式的4元组来表示，其中 $(x, y)$ 是中心的空间坐标，$w$ 是宽度，$h$ 是高度。假设从给定的图像 $I$ 中画出一个物体，那么它的位置和形状可以被认为遵循以 $I$ 为条件的分布，公式表示为：&lt;/p&gt;

\[p(x,y,w,h|I) = p(x,y|I)p(w,h|x,y,I)\]

&lt;p&gt;这种分解得到两个重要的直觉：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;给定一幅图像，物体可能只存在于某些区域&lt;/li&gt;
  &lt;li&gt;物体的形状，即尺寸和纵横比，与它的位置密切相关&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;根据上述两个直觉，设计出一个锚框生成模块（自适应），如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/context/GA-framework.png&quot; alt=&quot;GA-framework&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首先将各层特征图 $F_i$ 送入位置预测分支和形状预测分支，分别产生一个物体可能存在的概率图和位置相关的形状。再通过选择位置概率高于某阈值的位置和每个所选位置最可能的形状来生成一组锚框。&lt;/p&gt;

&lt;p&gt;由于锚框的形状可能不同，不同位置的特征应该捕获不同范围内的视觉内容（打破一致性原则）。考虑到这一点，进一步引入了特征自适应模块，该模块根据锚框形状对特征进行自适应。&lt;/p&gt;

&lt;p&gt;==请注意，在设计中，锚生成参数在所有涉及的特征级别上共享，因此该方案是参数高效的。==&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.1 Anchor Location Prediction&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如图 1 所示，概率图 $p(\cdot｜F_i)$ 的大小与特征图 $F_i$ 大小一致，通道数为1。其中每个 $p(i,j｜F_i)$  对应于原图坐标 $(\frac{i+1}{2}s,\frac{j+1}{2}s)$，其中 s 为该特征图的步长，该项的值表示物体的中心存在于该位置的概率。&lt;/p&gt;

&lt;p&gt;实现中，该概率图是由 $N_L$ 网络进行预测。网络将 $1 \times 1$ 卷积应用于特征图 $F_i$，获得物体性分数 map，然后通过 sigmoid 函数将其转化为概率值。（一层 Conv + sigmoid 在效率和准确度之间取得了很好的平衡）&lt;/p&gt;

&lt;p&gt;通过生成的概率图，可以选择相对概率值高的阈值 $\epsilon_L$ 来确定可能寻在物体的区域（保持相同召回率情况下可过滤掉90%的区域）。由于不需要考虑那些被排除的区域，可以将后续的卷积层替换为掩码卷积，以获得更有效的推理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.2 Anchor Shape Prediction&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在确定物体可能的位置之后，下一步是确定每个位置上可能存在的物体的形状。这是由锚的形状预测分支完成的，如图 1 所示。这个分支与传统的边界盒回归有很大的不同，因为它不会改变锚框的位置，也不会导致锚框和锚框特征之间的错位。具体来说，给定一个特征图 $F_i$，该分支将预测每个位置的最佳形状 (w, h)，即使之达到与最近的 ground-truth 包围框的最高覆盖率的形状。&lt;/p&gt;

&lt;p&gt;根据经验发现，直接预测这两个数字是不稳定的，因为它们的范围很大。相反，采用以下转换效果更好：&lt;/p&gt;

\[w=\sigma \cdot s \cdot e^{dw}, \space \space \space \space h=\sigma \cdot s \cdot e^{dh}\]

&lt;p&gt;其中 s 为步长，$\sigma$ 为经验比例因子（一般设置 $\sigma$ = 8）。这种非线性转换将将输出空间从近似 $[0, 1000]$ 投影到$[-1, 1]$，从而可以获得更容易且稳定的学习。&lt;/p&gt;

&lt;p&gt;实现中，该形状由 $N_S$ 网络进行预测。网络将 $1 \times 1$ 卷积应用于特征图 $F_i$，生成包含 $dw$ 和 $dh$ 的双通道映射，并通过上述公式进行转换。&lt;/p&gt;

&lt;p&gt;这种设计与传统的锚定方案有本质上的不同，因为每个位置只与动态预测形状的一个锚框相关联，而不是与一组预定义形状的锚框相关联。实验表明，由于位置和形状之间的密切关系，此方案可以获得比基线方案（统一均匀生成方案）更高的召回率。由于它允许任意的纵横比（可学习性），此方案可以更好地捕捉那些极高或极宽的物体。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.3 Anchor-Guided Feature Adaptation&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在常规的 anchor-based 检测器中，锚框在整个特征图上是均匀的，即锚框在每个位置上具有相同的形状和比例。因此，特征图可以学习一致的表示。在本方案中，锚框形状因位置而异，这种情况下，发现遵循前面的规定并不是一个很好的选择（卷积是在特征图上统一应用）。理想情况是，大型锚框应该在在大范围内编码内容，小型锚框相应的应该具有较小的作用域。&lt;/p&gt;

&lt;p&gt;根据此直觉，进一步设计了锚框引导的特征自适应组件，它将根据锚的形状在每个单独的位置上进行特征转换，表示如下：&lt;/p&gt;

\[f_i^{'} = N_T(f_i, w_i, h_i)\]

&lt;p&gt;其中 $f_i$ 为第 i 个位置的特征，$(w_i, h_i)$ 为对应的锚框形状。&lt;/p&gt;

&lt;p&gt;实现中，采用 $3\times3$ 的可变性卷积来实现 $N_T$ 网络。如图 1 所示，首先从锚框预设分支拿到一个偏移场，然后对偏移场的原始特征进行可变性卷积，得到 $f_i^{‘}$ (自适应后特征)。之后可以进行进一步的分类和边界框的回归。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.4 Training&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;a. Joint objective&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;此框架使用多任务损失的端到端方式进行优化。除了传统的分类损耗 $L_{cls}$ 和回归损耗 $L_{reg}$ 外，还引入了锚定位 $L_{loc}$ 和锚形状预测 $L_{shape}$ 两种额外的损失。他们以以下的损失 $L$ 共同优化：&lt;/p&gt;

\[L = \lambda_1 \cdot L_{loc} + \lambda_2 \cdot L_{shape} + L_{cls} + L_{reg}\]

&lt;p&gt;&lt;strong&gt;b. Anchor location targets&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为了训练锚框定位分支，对于每个图像，都需要一个二进制标签映射，用 1 表示放置锚框的有效位置，0 为无效。此处采用 ground-truth 边界框来指导标签映射的生成（期望物体中心附近放置更多锚框，远离中心尽量少）。&lt;/p&gt;

&lt;p&gt;用 $(x_g,y_g,w_g,x_g)$ 表示真值框，经其映射到各特征图，得到 $(x_g^{‘},y_g^{‘},w_g^{‘},x_g^{‘})$ ，将 $R(s,y,w,h)$ 表示为中心为 $(x,y)$ ，大小为 $w \times h$ 的矩形区域。更具上述期望，定义三种类型区域：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;center region: $CR=R(x_g^{‘},y_g^{‘},\sigma_1 w_g^{‘},\sigma_1 x_g^{‘})$  表示为中心区域，其中的像素被分配为正样本&lt;/li&gt;
  &lt;li&gt;ignore region: $IR=R(x_g^{‘},y_g^{‘},\sigma_2 w_g^{‘},\sigma_2 x_g^{‘}) \setminus CR$  是一个较大的 $(\sigma_2&amp;gt;\sigma_1)$ 不包括 $CR$ 的区域，表示为忽略区域，训练时被排除&lt;/li&gt;
  &lt;li&gt;outside region: $OR$ 不包含 $CR$ 和 $OR$ 的特征图区域，像素被分配为负样本&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/context/GA-mul-loc.png&quot; alt=&quot;Anchor-location&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此处还考虑了相邻特征图的影响，具体来说，每个级别的特征图应该只针对特定比例范围的对象，因此仅在特征图与目标对象的比例范围匹配时才在特征图上分配 $CR$。相邻层的相同区域设置为IR，如图 2 所示（$CR$ 可以抑制 $IR$ ，$IR$ 可以抑制 $OR$）。由于 $CR$ 通常只占整个特征图的一小部分，所以使用 Focal Loss 来训练位置分支。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;c. Anchor shape targets&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;由于本方案中锚框的 w 和 h 不是预定的，而是变量，就无法直接进行分配并计算 IoU。为了克服这个问题，进行如下函数优化：&lt;/p&gt;

\[vIoU(a_{wh},gt)=\max_{w&amp;gt;0,h&amp;gt;0}IoU_{normal}(a_{wh},gt)\]

&lt;p&gt;其中 $IoU_{normal}$ 为原始 $IoU$ 定义，w 和 h 为变量，$a_{wh}$ 为任意位置 $(x_0,y_0)$ 处的锚框，$gt$ 为真值框。但由于 $vIoU(a_{wh},gt)$ 表达式的复杂性，很难在网络中有效的实现。因此采用另一种方法来近似。在 $(x_0,y_0)$ 处，对 w 和 h 的一些公共值进行采样，以模拟所有 w 和 h 的枚举。然后用 $gt$ 计算这些采样锚的 $IoU$，并使用最大值作为 $vIoU(a_{wh},gt)$ 的近似值。&lt;/p&gt;

&lt;p&gt;在实验中，采用 RetinaNet 中的 9 种不同尺度和横纵比进行采样模拟（采样越多，模拟越精确，但计算成本更重）。采用 bound IoU Loss 来训练形状分支。损失函数表达式如下：&lt;/p&gt;

\[L_{shape}=L_1(1-min( \frac{w}{w_g}, \frac{w_g}{w})) + L_1(1-min( \frac{h}{h_g}, \frac{h_g}{h}))\]

&lt;p&gt;其中 $(w, h)$ 和 $(w_g, h_g)$ 分别表示为预测的宽高和真实的宽高，$L_1$ 为 Smooth L1 Loss。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;d. The Use of High-quality Proposals&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;GA-RPN 相对于 RPN 有两点优势：（1）正提议数量更多；（2）高 $IoU$ 提议的比率更为显著。&lt;/p&gt;

&lt;p&gt;直接使用 GA-RPN 代替 RPN 并不能带来很好的收益（涨点不到 1）。由于使用高质量提议的前提是根据提议的分布调整训练样本的分布，因此，与 RPN 相比，设置更高的正/负阈值，并在使用 GA-RPN 时使用更少的训练样本，可以获得更高的收益。&lt;/p&gt;

&lt;p&gt;此外，可以使用 GA-RPN 通过微调来提高训练好的两阶段检测器。具体来说，给定一个训练好的模型，放弃建议生成组件（RPN)，并使用预先计算的 GA-RPN 对它进行几个 epoch (默认为 3 个 epoch ) 的微调，GA-RPN 也用于推理。这种简单的微调方案只需要几个 epoch 的时间成本，就可以获得进一步大幅度的性能提升。&lt;/p&gt;

&lt;h3 id=&quot;3-experiments&quot;&gt;3. Experiments&lt;/h3&gt;

&lt;p&gt;下述所有实验均在 MS COCO 2017 上进行。&lt;/p&gt;

&lt;p&gt;如果没有特殊说明，所有实验采用 ResNet-50 作为主干网络，FPN 作为颈部网络。图像调整大小为 $1333 \times 800$ 并不改变横纵比。设置参数 $\sigma_1=0.2, \space \sigma_2=0.5$。多任务损函数中，设置 $\lambda_1=1, \space \lambda_2=0.1$ 来平衡位置和形状预测分支。&lt;/p&gt;

&lt;p&gt;RPN 的结果用平均召回率（AR）来衡量。AR 是阈值从 0.5 到 0.95 的召回率的平均值。每张图像100、300和1000个提议的 AR 分别表示为 $AR_{100}、AR_{300}$ 和 $AR_{1000}$。小型、中型和大型对象（$AR_S、AR_M、AR_L$）的 AR 为 100 个提议计算。检测结果使用标准 COCO 度量进行评估，该度量为 IoU 的 mAP 从 0.5 到 0.95。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/context/GA-result1.png&quot; alt=&quot;GA-result&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中，RPN + 9 anchors 为使用 3 个尺度 3 个比率；RPN + Focal Loss 和 RPN + Bounded IoU Loss 分别为替换 RPN 中原有的 Cross-Entropy Loss 和 Smooth L1 Loss；RPN + Iterative 为采用两次 RPN head，并且中间用 $3 \times 3$ 卷积层连接；RefineRPN 为锚框根据 FPN前后特征进行两次回归和分类。 可以看到，AR 的值都在显著的提升，GA-RPN 的平均查全率最大，尤其表现在中大型目标上。&lt;/p&gt;

&lt;p&gt;同时，其对于 AP 的提升也十分明显，应用在 anchor-based 的检测器，在 COCO 数据集上基本会得到 2 个点左右的 mAP 提升。如下图所示：&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
    &lt;img src=&quot;/assets/images/context/GA-result2.png&quot; width=&quot;60%&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;下图为 RPN 和 GA-RPN 的可视化结果，可以看到 GA-RPN 提议的框更少，但更精确。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
	&lt;img src=&quot;/assets/images/context/GA-result3.png&quot; width=&quot;80%&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;更多详细的消融实验见论文原文，实现代码详见 mmdetation 官方仓库。&lt;/p&gt;
</description>
        <pubDate>Mon, 06 Mar 2023 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2023/03/06/GA_RPN.html</link>
        <guid isPermaLink="true">http://localhost:4000/2023/03/06/GA_RPN.html</guid>
        
        <category>DeepLearning</category>
        
        <category>ReadPaper</category>
        
        
      </item>
    
      <item>
        <title>Binary Search Algorithm</title>
        <description>&lt;h2 id=&quot;二分查找算法的-c-实现与-stl-库调用实现&quot;&gt;二分查找算法的 C++ 实现与 STL 库调用实现&lt;/h2&gt;

&lt;p&gt;二分查找（折半查找）即二分搜索，是一种在&lt;strong&gt;有序数组&lt;/strong&gt;中查找某一特定元素的搜索算法。二分查找有两个要求，一个是数列有序，另一个是数列使用顺序存储结构，例如数组。其时间复杂度为 $O(log_2 n)$。&lt;/p&gt;

&lt;p&gt;使用 C++ 实现代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

// 迭代二分查找
int iterationBinarySearch(int *a, int x) {
  	int left = 0;
    int right = n - 1;
    while(left &amp;lt;= right) {
        int mid = (left + right) / 2;
        if(x &amp;gt; a[mid]) left = mid + 1;
        else if(x &amp;lt; a[mid]) right = mid - 1;
      	else return mid;
    }
    return -1;
}

// 递归二分查找
int recurisonBinarySearch(int *a, int left, int right, int x) {
    if(left &amp;gt; right) return -1;
    int mid = (left + right) / 2;
  	if(x &amp;gt; a[mid]) return recurisonBinarySearch(a, mid + 1, right, x);
  	else if(x &amp;lt; a[mid]) return recurisonBinarySearch(a, left, mid - 1, x);
    else return mid;
}

int main() {
  	int a[10] = {1, 5, 9, 14, 17, 21, 25, 30, 37, 40};
  	iterationBinarySearch(a, 30);
  	recurisonBinarySearch(a, 0, 9, 30);
  	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 STL 中，也提供了相应的函数接口，使用前进行头文件引入：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#include &amp;lt;algorithm&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;

int main(){
  	int a[10] = {1, 5, 9, 14, 17, 21, 25, 30, 37, 40};
  	binary_search(a, a+9, 30);	// 参数列表（首地址，尾地址，查找元素），返回bool类型
  	
  	lower_bound(a, a+9, 9);		// 返回第一个大于或等于某元素的位置(地址)，pos-a 为所需要的索引
  	upper_bound(a, a+9, 9);		// 返回第一个大于某元素的位置(地址)，pos-a 为所需要的索引
  	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lower_bound&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;upper_bound&lt;/code&gt; 都在 &lt;strong&gt;前闭后开&lt;/strong&gt; 的区间中进行二分查找，如果所有元素均小于等于（lower）或小于（upper）该元素，则返回 last 位置。（&lt;strong&gt;&lt;em&gt;注意：&lt;/em&gt;&lt;/strong&gt; 数组会发生越界）&lt;/p&gt;
</description>
        <pubDate>Sun, 05 Mar 2023 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2023/03/05/binarySearch.html</link>
        <guid isPermaLink="true">http://localhost:4000/2023/03/05/binarySearch.html</guid>
        
        <category>Algorithm</category>
        
        
      </item>
    
      <item>
        <title>Docker 环境中从零开始搭建 Pytorch 环境</title>
        <description>&lt;h2 id=&quot;ubuntu-1804-作为最底层-docker-镜像从零开始搭建-pytorch-环境&quot;&gt;ubuntu 18.04 作为最底层 Docker 镜像，从零开始搭建 Pytorch 环境&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;ubuntu 18.04 镜像搭建是从 Docker 官网拉取的&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;基本环境安装 (Miniconda, CUDA)&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 进入镜像
docker run &lt;span class=&quot;nt&quot;&gt;-it&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--gpus&lt;/span&gt; all ubuntu:18.04 /bin/bash

2. 安装 &lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;和 wget
apt update
apt &lt;span class=&quot;nb&quot;&gt;install sudo
sudo &lt;/span&gt;apt &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;wget

3. 安装 miniconda
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;home/
wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh
&lt;span class=&quot;nb&quot;&gt;chmod&lt;/span&gt; +x Miniconda3-latest-Linux-x86_64.sh
./Miniconda3-latest-Linux-x86_64.sh

4. 安装一些依赖项
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt-get &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;libxml2 gcc g++ vim

5. 下载 cuda 并安装
wget https://developer.download.nvidia.com/compute/cuda/11.6.0/local_installers/cuda_11.6.0_510.39.01_linux.run
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;sh cuda_11.6.0_510.39.01_linux.run
设置环境变量：
vim ~/.bashrc
文件最后保存一下路径描述
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;LD_LIBRARY_PATH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$LD_LIBRARY_PATH&lt;/span&gt;:/usr/local/cuda-11.6/lib64
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;PATH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$PATH&lt;/span&gt;:/usr/local/cuda-11.6/bin
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;CUDA_HOME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$CUDA_HOME&lt;/span&gt;:/usr/local/cuda-11.6
更新环境变量
&lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt; ~/.bashrc

6. cudnn 安装
https://developer.nvidia.com/rdp/cudnn-archive 网址下载相应的tar文件，deb方式卸载更新起来不太方便，容易出问题。
解压 &lt;span class=&quot;nb&quot;&gt;tar&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-xvJf&lt;/span&gt; cudnn-linux-x86_64-8.4.1.50_cuda11.6-archive.tar.xz
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;cudnn-linux-x86_64-8.4.1.50_cuda11.6-archive

拷贝到容器：docker &lt;span class=&quot;nb&quot;&gt;cp &lt;/span&gt;本地文件 容器ID：容器路径
docker &lt;span class=&quot;nb&quot;&gt;cp &lt;/span&gt;include/cudnn&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.h 容器ID：/usr/local/cuda/include
docker &lt;span class=&quot;nb&quot;&gt;cp &lt;/span&gt;lib64/libcudnn&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; 容器ID：/usr/local/cuda/lib64
给予执行权限
&lt;span class=&quot;nb&quot;&gt;sudo chmod &lt;/span&gt;a+r /usr/local/cuda/include/cudnn&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.h /usr/local/cuda/lib64/libcudnn&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;

测试cudnn（8.0以后版本）
&lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; /usr/local/cuda/include/cudnn_version.h | &lt;span class=&quot;nb&quot;&gt;grep &lt;/span&gt;CUDNN_MAJOR &lt;span class=&quot;nt&quot;&gt;-A&lt;/span&gt; 2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;将 jittor 拷入环境并安装&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 将JDet_temp 拷贝到容器home文件夹下，并更名JDet
docker cp JDet_Temp 容器ID:/home/
mv JDet_Temp JDet (容器内执行)

2. 配置环境
cd JDet
python -m pip install -r requirements.txt
python setup.py develop
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;安装 jittor 所需的额外包以及 DOTA_devkit 的 bulid&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 安装依赖包
apt-get update &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; apt-get &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;libgl1 libglib2.0-dev

2. DOTA_devkit 中 bulid 安装
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;DOTA_devkit
python setup.py build_ext &lt;span class=&quot;nt&quot;&gt;--inplace&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Docker 镜像的加载和保存&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 保存镜像
$ docker save 镜像名称 | gzip &amp;gt; XXXX-latest.tar.gz

2. 加载镜像
$ docker load -i XXXX-latest.tar.gz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Sat, 04 Mar 2023 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2023/03/04/Docker.html</link>
        <guid isPermaLink="true">http://localhost:4000/2023/03/04/Docker.html</guid>
        
        <category>Docker</category>
        
        
      </item>
    
      <item>
        <title>Awesome Backnone Plan</title>
        <description>&lt;h2 id=&quot;主干网络大汇总&quot;&gt;主干网络大汇总&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;针对现有 Backbone 的学习笔记&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;针对网络结构细微调整和训练策略的研究&quot;&gt;针对网络结构细微调整和训练策略的研究&lt;/h3&gt;
&lt;p&gt;论文链接地址：&lt;a href=&quot;https://arxiv.org/pdf/1812.01187.pdf&quot;&gt;Bag of Tricks for Image Classification with Convolutional Neural Networks&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Efficient Training&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;large-batch training&lt;/strong&gt; ｜ 对于凸优化问题，随着 batch 的增加其收敛速率会降低，神经网络也会存在这样的问题。
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;linear scaling learning rate&lt;/strong&gt;&lt;br /&gt;
增加 batch 时不会改变期望，但方差会减小。换句话说，大的 batch 会减少梯度中的噪声，所以增加学习率沿着梯度方向相反的方向可以加速网络收敛。假设 ResNet-50 的训练以 0.1 &lt;em&gt;learning rate&lt;/em&gt;，256 batch size 为基准，当我们改变训练的 batch 大小时（假设改为b），那么应该调整学习率为 &lt;em&gt;lr=0.1 x b/256&lt;/em&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;learning rate warmup&lt;/strong&gt;&lt;br /&gt;
初始化时整个网络的参数是随机的，远离最终优化后的结果。太大的学习率导致训练初期不稳定，采用学习率升温的策略，即从一个很小的学习率逐渐上升到初始学习率，可稳定初期的训练，便于得到最优的性能。一般用线性升温的学习率策略，假设使用前 m 次迭代，初始的学习率为 a，则每次迭代的学习率为 i · a / m&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;zero $\gamma$&lt;/strong&gt;&lt;br /&gt;
对每一个 resnet 块的最后一个 BN 层的 weight 进行初始化为 0 的操作， 这样所有的块都返回他们的输入，模拟层数较少且更容易训练的初始阶段&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;No bias decay&lt;/strong&gt;&lt;br /&gt;
权重衰减应用于所有可学习参数，weight 和 bias。其就像在所有参数上应用 L2 正则化。仅对 weight 使用正则化可避免过拟合。==（没太理解）==&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;low-precision training&lt;/strong&gt; ｜ 将模型精度从 FP32 转为 FP16 可将训练速度提升 2～3 倍，精度不会大幅度降低且有时会有更高的结果。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Model Tweaks&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/context/resnet_tweak.png&quot; alt=&quot;ResNet architecture and some tweaks&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;ResNet-B&lt;/strong&gt; ｜  其认为在 block 中第一个 1x1 的卷积使用步长为 2 会丢失觉很大一部分信息，将其移致 3x3 的卷积更为合理。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ResNet-C&lt;/strong&gt; ｜  因为卷积的计算复成本和其核边长是二次相关的，其将最前面的 7x7 卷积用 3 个 3x3 的卷积替换，以降低其计算成本。具体细节是将通道数变化改为 3 » 32，32 » 32，32 » 64，对应的步长分别是 2，2，1。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ResNet-D&lt;/strong&gt; ｜  论文中提出的，灵感来源于 &lt;em&gt;ResNet-B&lt;/em&gt; 结构。其发现下采样路径中使用的卷积大小为 1x1，但其步长为 2，这样的卷积会都是一部分信息。在 1x1 卷积的前面加上一个步长为 2 的全局平均池化（GAP）并将 1x1 卷积步长恢复到 1，这样可以在无参数增加、仅增加小部分计算量的前提下提升网络的精度。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上消融实验结果如下所示。（采用 Efficient Training 中所有 tricks，需要注意的是&lt;strong&gt;三个 tweak 是逐级叠加的优化&lt;/strong&gt;）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/context/resnet_tweak_ablation.png&quot; alt=&quot;resnet_tweak_ablation&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Training Refinements&lt;/strong&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 04 Mar 2023 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2023/03/04/AwesomeBackbonePlan.html</link>
        <guid isPermaLink="true">http://localhost:4000/2023/03/04/AwesomeBackbonePlan.html</guid>
        
        <category>DeepLearning</category>
        
        <category>ReadPaper</category>
        
        
      </item>
    
  </channel>
</rss>
